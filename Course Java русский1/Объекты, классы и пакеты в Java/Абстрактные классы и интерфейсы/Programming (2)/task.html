Пришло время попробовать реализовать иерархию классов определенного вида и решить конкретную задачу.<br><br>Представим, вы делаете систему фильтрации комментариев на каком-то веб-портале, будь то новости, видео-хостинг, а может даже для системы онлайн-обучения :)<br><br>Вы хотите фильтровать комментарии по разным критериям, уметь легко добавлять новые фильтры и модифицировать старые.<br><br>Допустим, мы будем фильтровать спам, комментарии с негативным содержанием и слишком длинные комментарии.<br> Спам будем фильтровать <b>по наличию указанных ключевых слов в тексте</b>. <br>Негативное содержание будем определять по наличию одного из трех смайликов – <b>:( =( :|</b><br>Слишком длинные комментарии будем определять исходя из данного числа – <b>максимальной длины</b> комментария.<br><br>Вы решили абстрагировать фильтр в виде следующего интерфейса:<br><pre><code class="language-java">interface TextAnalyzer {
    Label processText(String text);
}</code></pre>Label – тип-перечисление, которые содержит метки, которыми будем помечать текст:<br><pre><code class="language-java">enum Label {
    SPAM, NEGATIVE_TEXT, TOO_LONG, OK
}
</code></pre>Дальше, <b>вам необходимо реализовать три класса, которые реализуют данный интерфейс: SpamAnalyzer, NegativeTextAnalyzer и TooLongTextAnalyzer.</b><br><ol><li><b>SpamAnalyzer должен конструироваться от массива строк с ключевыми словами. Объект этого класса должен сохранять в своем состоянии этот массив строк в приватном поле keywords.</b></li><li><b>NegativeTextAnalyzer должен конструироваться конструктором по-умолчанию. </b></li><li><b>TooLongTextAnalyzer должен конструироваться от int'а с максимальной допустимой длиной комментария. Объект этого класса должен сохранять в своем состоянии это число в приватном поле maxLength.</b></li></ol>Наверняка вы уже заметили, что SpamAnalyzer и NegativeTextAnalyzer во многом похожи – они оба проверяют текст на наличие каких-либо ключевых слов (в случае спама мы получаем их из конструктора, в случае негативного текста мы заранее знаем набор грустных смайликов) и в случае нахождения одного из ключевых слов возвращают  Label (SPAM и NEGATIVE_TEXT соответственно), а если ничего не нашлось – возвращают OK.<br>Давайте эту логику <b>абстрагируем в абстрактный класс <b>KeywordAnalyzer</b></b> следующим образом:<br><ol><li> <b>Выделим два абстрактных метода getKeywords и getLabel,</b> один из которых будет возвращать набор ключевых слов, а второй метку, которой необходимо пометить положительные срабатывания. Нам незачем показывать эти методы потребителям классов, поэтому <b>оставим доступ к ним только для наследников.</b></li><li><b>Реализуем processText</b> таким образом, чтобы он зависел только от getKeywords и getLabel.</li><li><b>Сделаем SpamAnalyzer и NegativeTextAnalyzer наследниками KeywordAnalyzer и реализуем абстрактные методы.</b></li></ol><br>Последний штрих – написать метод checkLabels, который будет возвращать метку для комментария по набору анализаторов текста. checkLabels должен возвращать первую не-OK метку в порядке данного набора анализаторов, и OK, если все анализаторы вернули OK.<br>Используйте, пожалуйста, модификатор доступа по-умолчанию для всех классов.<br>В итоге, реализуйте классы KeywordAnalyzer, SpamAnalyzer, NegativeTextAnalyzer и TooLongTextAnalyzer и метод checkLabels. TextAnalyzer и Label уже подключены, лишние импорты вам не потребуются.<br><br><br><font color="gray">Memory limit: 256 MB</font><br><font color="gray">Time limit: 8 seconds</font><br><br>